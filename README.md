
ngbs-forms
==========

> Generate forms using Angular for validations and Bootstrap for styles from short and concise descriptions of the fields.

 * [Install](#install)
 * [Getting started](#getting-started)
 * [API](#API)
 * [Form files](#validator-files)
 * [Form descriptors reference](#form-descriptors-reference)
 * [Fields reference](#fields-reference)
 * [Validators reference](#validators-reference)


## <a name="install"></a> Install

```shell
npm install --save-dev ngbs-forms
```

There are plugins for [Grunt](https://github.com/ernestoalejo/grunt-ngbs-forms)
and [Gulp](https://github.com/ernestoalejo/gulp-ngbs-forms).


## <a name="getting-started"></a> Getting started

Create a `example.frm` file containing this:

```
form {
  fields {
    input foo {}
  }
}
```

Then you can compile it from Javascript:

```js
var forms = require('ngbs-forms'),
    fs = require('fs');

var contents = fs.readFileSync('example.frm');
var source = forms.parse(contents.toString());
var generated = forms.generate(source);
fs.writeFileSync('example.html');
```

Then include somehow the partial in your app (using ng-include or ng-view for example)
and use this javascript to manage the form:

```js
.controller('MyController', function($scope) {
  // Initial data of the form, you can provide default values if you want
  $scope.data = {};

  // Called when the form is submitted, save the data and do whatever you want
  $scope.submit = function() {
    MyEntity.save($scope.data).then(...);
  };
});
```


## <a name="API"></a> API

This library exposes two functions.

**`parse(strval)`**: Parse the string (read from a file for example) and return a
descriptor object containing the full structure of the file.

**`generate(descriptor)`**: Takes descriptor object generated by `parse`. Returns
a string with the generated HTML code.


## <a name="form-files"></a> Form files

Form files are written in a custom and concise language.

 * [Forms](#forms)
 * [Fields](#fields)
 * [Validators](#validators)
 * [Comments](#comments)


### <a name="forms"></a> Forms

The basic structure of a file describes a form.

```
form {
  fields {
    [...my fields here...]
  }
}
```

You can specify descriptors for the form, changing the name for example:

```
form {
  name = 'myformname'

  fields {
    [...my fields here...]
  }
}
```


### <a name="fields"></a> Fields

Most of the fields (like inputs, selects, checkboxes, etc.) receive a list of
descriptors and the validators for that field.

For example, a simple input with the label and the placeholder setted. It will
save the data to "$scope.data.foo".

```
form {
  fields {
    input foo {
      label = 'My field label'
      placeholder = 'My input placeholder'
    }
  }
}
```

Some descriptors can be a list of (key, value) pairs. For example you can
pass additional attributes to the input tag using `attrs`.

```
form {
  fields {
    input foo {
      label = 'My label'

      attrs {
        style = 'width: 150px;'
        my-custom-attr = 'my-custom-value'
      }
    }
  }
}
```


### <a name="validators"></a> Validators

To add validators to the fields specify them in a `validators` section.
They can take arguments if needed. The error message will be displayed after the
first submit try for fields that don't pass the validation.

```
form {
  fields {
    input foo {
      label = 'My label'

      validators {
        required = 'Foo is required'
        minlength(3) = 'Foo should have at least 3 characters'
        regexp('/^[a-c]$/') = 'Foo should be composed of "a", "b" and "c" only.'
      }
    }
  }
}
```


### <a name="comments"></a> Comments

Finally, this wouldn't be a good language if things can't be commented out quickly.
You can make comments using the `/*` and `*/` syntax.

```
form {
  fields {
    input foo {} /* comment, this will get ignored */
    /*
      it can span several lines if you need it
     */
    select bar {}
  }
}
```


## <a name="requirements-reference"></a> Requirements reference

 * [custom](#custom)
 * [datetime](#datetime)
 * [email](#email)
 * [in](#in)
 * [inarray](#inarray)
 * [length](#length)
 * [match](#match)
 * [maxdatetime](#maxdatetime)
 * [maxlength](#maxlength)
 * [maxvalue](#maxvalue)
 * [mindatetime](#mindatetime)
 * [minlength](#minlength)
 * [minvalue](#minvalue)
 * [positive](#positive)
 * [regexp](#regexp)
 * [required](#required)
 * [store](#store)
 * [url](#url)
 * [use](#use)


### <a name="custom"></a> custom
*Applies to*: `string`, `boolean`, `integer`, `float`.
*Args*: `code (string)`.
*Requires*: `store`

Allows you to apply custom validations **to this field**. If you want to apply more
general conditions use [Conditionals](#conditionals) better.

It requires that you store first the value of the field.

The argument received should be valid PHP code.

```
string myfield {
  required
  minlength(3)

  store("myfield")

  custom("$store['myfield'] === 'foo'")
}
```


### <a name="datetime"></a> datetime
*Applies to*: `string`.
*Args*: `no args`.

Checks that the field it's a valid datetime. It uses the Carbon library, so the
expected formats are any of the accepted ones by the constructor.


### <a name="email"></a> email
*Applies to*: `string`.
*Args*: `no args`.

Validates email addresses using the same regular expression that Angular.JS uses.


### <a name="in"></a> in
*Applies to*: `string`.
*Args*: `values (string)`.

Checks that the received string is one of the provided. You can specify as many
arguments as you need.

```
string foo {
  in("foo")
}

string foobar {
  in("foo", "bar", "baz", "qux")
}
```


### <a name="inarray"></a> inarray
*Applies to*: `string`.
*Args*: `array name (string)`.

The same as `in`, but allows you to easily read a runtime array for the list.

```
string lang {
  required
  use("Config")
  inarray("Config::get('langs.available')")
}
```


### <a name="length"></a> length
*Applies to*: `string`.
*Args*: `length (integer)`.

The length of the string should match exactly that number of characters.


### <a name="match"></a> match
*Applies to*: `string`.
*Args*: `stored (string)`.

Checks that the value matchs a previously stored one.


### <a name="maxdatetime"></a> maxdatetime
*Applies to*: `string`.
*Args*: `datetime (string)`.
*Requires*: `datetime`.

Check value to see if it's equal or before the specified limit. Datetime could be any
string that the Carbon constructor can read.


### <a name="maxlength"></a> maxlength
*Applies to*: `string`.
*Args*: `length (integer)`.

Checks that the string has less or equal characters than the maximum.


### <a name="maxvalue"></a> maxvalue
*Applies to*: `integer`, `float`.
*Args*: `limit (integer)`.

Checks that the field value it's less or equal than the provided limit (it's inclusive).


### <a name="mindatetime"></a> mindatetime
*Applies to*: `string`.
*Args*: `datetime (string)`.
*Requires*: `datetime`.

Check value to see if it's equal or after the specified limit. Datetime could be any
string that the Carbon constructor can read.


### <a name="minlength"></a> minlength
*Applies to*: `string`.
*Args*: `length (integer)`.

If the string is not empty, it should have at least that number of characters.
To check for empty strings use the `required` requirement.


### <a name="minvalue"></a> minvalue
*Applies to*: `integer`, `float`.
*Args*: `limit (integer)`.

Checks that the field value it's equal or greater than the provided limit (it's inclusive).


### <a name="positive"></a> positive
*Applies to*: `integer`, `float`.
*Args*: `no args`.

Checks the value to see if it's equal or greater than zero. It's equivalent to `minvalue(0)`.


### <a name="regexp"></a> regexp
*Applies to*: `string`.
*Args*: `regexp (string)`.

Apply a regexp to the value to see if it matches. Remember the regexp should be valid in PHP.

```
string myfield {regexp("/[a-z][0-9]/")}
```

### <a name="required"></a> required
*Applies to*: `string`.
*Args*: `no args`.

The string should have one or more characters.


### <a name="store"></a> store
*Applies to*: `string`, `integer`, `float`, `boolean`.
*Args*: `name (string)`.

Save the value of this field in the `$store` array, under the provided name. You
can later access it in conditionals and switchs like `$store['name']`.

See [Conditionals](#conditionals) for more info.


### <a name="url"></a> url
*Applies to*: `string`.
*Args*: `no args`.

Validate URLs using the same regular expression Angular.JS uses.


### <a name="use"></a> use
*Applies to*: `string`, `boolean`, `integer`, `float`.
*Args*: `class (string)`.

Imports a new class into the runtime PHP file.

```
string lang {
  required
  use("Config")
  store("lang")
  custom("Config::get('langs.' . $store['lang']) === 'active'")
}
```


